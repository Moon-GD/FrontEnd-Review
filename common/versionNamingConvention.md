# version naming Convention : semVer, calVer

<br />

## 1️⃣ (공통) 필요성
- 의미있게 버전 정보를 작성함으로써, 개발자 간 업데이트 유형, 시간 흐름, 버전 간의 호환성 여부 등의 정보 제공 가능
- 다양한 방식이 존재하지만, 그 중 semVer & calVer에 대해서 알아보고자 합니다 <br />
    - <a href="https://blog.sonim1.com/243">다른 방식도 살펴보기</a>

<br />

## 2️⃣ semVer (semantic versioning)
### 버전 기입 방식
- major.minor.patch의 순서로 버전을 기입하며 각각 아래의 의미를 지님
    - major : 이전 버전과 호환되지 않는 기능이 포함되는 버전의 변경
    - minor : 이전 버전과 호환되며 새로운 기능을 추가할 때
    - patch : 이전 버전과 호환되며 버그를 수정할 때
 
<br />

### 유의 사항
- 버전 정보는 양의 정수로 표현하며, 숫자 간 길이를 맞추어주기 위해 0을 활용하면 안됨
    - wrong case → 12.08.01
    - correct case → 12.8.1
- 패키지가 한 번 릴리즈되면 해당 패키지는 수정이 되어선 안됨.
    - 수정이 필요한 경우, 새로운 버전으로 출시해야 함
- major 버전이 증가하면, minor와 patch는 0으로 초기화
- minor 버전이 증가하면, patch는 0으로 초기화

<br />

### 장점
- 호환성과 업데이트 정보를 용이하게 전달 가능

<br />

### 단점
- 잦은 릴리즈 발생이 가능
    - 버그 수정, 새로운 기능 추가 등이 발생할 때마다 버전을 다르게 기입해야 하기에 릴리즈 횟수가 상대적으로 늘어날 수 있음

<br />

## 3️⃣ calVer (calendar versioning)
### 버전 기입 방식
- 조직에 따라 조금씩 활용 방식이 다르긴 하지만 크게 아래의 구조를 지님
- year.month.build.status
    - year & month : 각각 릴리즈된 연도와 월을 의미
    - build : 숫자나 문자열로 같은 날짜에 릴리즈된 버전을 구분
    - status : 해당 버전에 대한 pre, lts, testing 등의 메타 정보를 제공

<br />

### 장점
- 직관적인 시간 표현으로 개발자와 사용자에게 다음 버전 출시 시간 정보를 제공 가능
- 버전의 흐름 관리가 용이함 → 릴리즈 노트 작성도 버전 순서로 하기에 편함

<br />

### 단점
- 업데이트에서 생긴 의미 있는 변화 파악이 어려움
    - ex : 2주만에 릴리즈된 건 알겠는데 뭐가 바뀐거지?

<br />

## 4️⃣ 참고 링크
- <a href="https://semver.org/">semVer 공식 문서</a>
- <a href="https://calver.org/">calVer 공식 문서</a>

<br />

<hr />

updated : 2023.08.19 (Sat)
